# -*- coding: utf-8 -*-
"""Untitled0.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/178cUtWgomWWQYH8AX_OlB-WES13JRzth
"""

from google.colab import files
uploaded = files.upload()

import pandas as pd
import matplotlib.pyplot as plt

df.info()

"""# Task
Analyze the "amazon.csv" dataset to identify top-selling products. This involves cleaning and converting numerical columns such as 'discounted_price', 'actual_price', 'discount_percentage', 'rating', and 'rating_count' to appropriate data types. Determine top-selling products based on 'rating_count' and visualize them using a bar chart. Additionally, clarify that calculating monthly revenue is not possible due to the absence of date or timestamp information in the dataset.

## Clean and Convert Numerical Columns

### Subtask:
Clean the 'discounted_price', 'actual_price', 'discount_percentage', 'rating', and 'rating_count' columns by removing special characters (like '₹', '%', ',') and converting them to appropriate numeric data types for analysis.

**Reasoning**:
I will clean and convert the specified numerical columns ('discounted_price', 'actual_price', 'discount_percentage', 'rating', 'rating_count') in the DataFrame. This involves removing special characters and converting them to appropriate numeric data types for analysis. I will also import `numpy` as `np` as requested to handle potential non-numeric values in the 'rating' column.
"""

import numpy as np

# Clean 'discounted_price'
df['discounted_price'] = df['discounted_price'].str.replace('₹', '').str.replace(',', '').astype(float)

# Clean 'actual_price'
df['actual_price'] = df['actual_price'].str.replace('₹', '').str.replace(',', '').astype(float)

# Clean 'discount_percentage'
df['discount_percentage'] = df['discount_percentage'].str.replace('%', '').astype(int)

# Handle 'rating'
df['rating'] = df['rating'].replace({'No rating available': np.nan}).astype(float)

# Clean 'rating_count'
df['rating_count'] = df['rating_count'].str.replace(',', '', regex=False).astype(float).astype('Int64') # Convert to float first to handle NaN, then to Int64 (nullable integer type)

print("Columns 'discounted_price', 'actual_price', 'discount_percentage', 'rating', and 'rating_count' have been cleaned and converted.")

df.info()

"""**Reasoning**:
The previous code failed because the 'rating' column contained characters like '|' that could not be directly converted to a float. To fix this, I will use `pd.to_numeric` with `errors='coerce'` on the 'rating' column, which will convert any non-numeric values (including '|' and 'No rating available') to `NaN`, allowing for proper conversion to float.


"""

import numpy as np

# Clean 'discounted_price'
df['discounted_price'] = df['discounted_price'].str.replace('₹', '').str.replace(',', '').astype(float)

# Clean 'actual_price'
df['actual_price'] = df['actual_price'].str.replace('₹', '').str.replace(',', '').astype(float)

# Clean 'discount_percentage'
df['discount_percentage'] = df['discount_percentage'].str.replace('%', '').astype(int)

# Handle 'rating' more robustly using pd.to_numeric with errors='coerce'
df['rating'] = pd.to_numeric(df['rating'].replace({'No rating available': np.nan}), errors='coerce')

# Clean 'rating_count'
df['rating_count'] = df['rating_count'].str.replace(',', '', regex=False)
df['rating_count'] = pd.to_numeric(df['rating_count'], errors='coerce').astype('Int64') # Convert to numeric first, then to nullable integer type

print("Columns 'discounted_price', 'actual_price', 'discount_percentage', 'rating', and 'rating_count' have been cleaned and converted.")

df.info()

"""**Reasoning**:
The previous code failed because some columns were no longer of string type when attempting to use the `.str` accessor, despite initial `df.info()` suggesting they were objects. This can happen if the execution state is not reset or if a previous partial execution changed the data type. To fix this, I will explicitly cast these columns to `str` type before applying string operations like `replace` to ensure the `.str` accessor works correctly and then convert them to the appropriate numeric types.


"""

import numpy as np
import pandas as pd # Ensure pandas is imported as well for pd.to_numeric

# Clean 'discounted_price'
df['discounted_price'] = df['discounted_price'].astype(str).str.replace('₹', '').str.replace(',', '').astype(float)

# Clean 'actual_price'
df['actual_price'] = df['actual_price'].astype(str).str.replace('₹', '').str.replace(',', '').astype(float)

# Clean 'discount_percentage'
df['discount_percentage'] = df['discount_percentage'].astype(str).str.replace('%', '').astype(int)

# Handle 'rating' more robustly using pd.to_numeric with errors='coerce'
df['rating'] = pd.to_numeric(df['rating'].astype(str).replace({'No rating available': np.nan}), errors='coerce')

# Clean 'rating_count'
df['rating_count'] = df['rating_count'].astype(str).str.replace(',', '', regex=False)
df['rating_count'] = pd.to_numeric(df['rating_count'], errors='coerce').astype('Int64') # Convert to numeric first, then to nullable integer type

print("Columns 'discounted_price', 'actual_price', 'discount_percentage', 'rating', and 'rating_count' have been cleaned and converted.")

df.info()

"""## Identify Top Selling Products

### Subtask:
Determine the top-selling products based on the 'rating_count' column, as it serves as a proxy for product popularity or units sold in this dataset. Aggregate the data to find products with the highest rating counts.

**Reasoning**:
To identify the top-selling products, I will sort the DataFrame by 'rating_count' in descending order and then select the top 10 entries.
"""

top_products = df.sort_values(by='rating_count', ascending=False).head(10)
print("Top 10 Selling Products based on Rating Count:")
print(top_products[['product_name', 'rating_count', 'rating', 'discounted_price']])

"""## Generate Top Products Graph

### Subtask:
Create a bar chart visualizing the top N products based on their 'rating_count' to clearly show the best-selling items. Ensure the graph includes appropriate labels and a legend.

**Reasoning**:
To visualize the top-selling products, I will create a bar chart using the `top_products` DataFrame, displaying `product_name` on the x-axis and `rating_count` on the y-axis, with appropriate labels and layout adjustments.
"""

plt.figure(figsize=(12, 6))
plt.bar(top_products['product_name'], top_products['rating_count'], color='skyblue')
plt.xlabel('Product Name')
plt.ylabel('Rating Count')
plt.title('Top 10 Products by Rating Count')
plt.xticks(rotation=90)
plt.tight_layout()
plt.show()

"""**Reasoning**:
The previous `plt.tight_layout()` call resulted in a `UserWarning` because the figure's bottom margin was insufficient to accommodate the rotated x-axis labels. To resolve this, I will explicitly adjust the subplot parameters to increase the bottom margin, ensuring all product names are visible without overlap.


"""

plt.figure(figsize=(12, 8)) # Increased figure height to provide more space
plt.bar(top_products['product_name'], top_products['rating_count'], color='skyblue')
plt.xlabel('Product Name')
plt.ylabel('Rating Count')
plt.title('Top 10 Products by Rating Count')
plt.xticks(rotation=90, ha='right') # Rotate labels and align right
plt.subplots_adjust(bottom=0.35) # Manually adjust bottom margin
plt.tight_layout()
plt.show()

"""**Reasoning**:
The previous code resulted in a `UserWarning` from `plt.tight_layout()` because the manually adjusted `subplots_adjust` was likely overridden or conflicted. To fix this, I will remove `plt.tight_layout()` and rely solely on `plt.subplots_adjust` with a slightly increased bottom margin to ensure all rotated x-axis labels are fully visible without issues.


"""

plt.figure(figsize=(12, 8)) # Increased figure height to provide more space
plt.bar(top_products['product_name'], top_products['rating_count'], color='skyblue')
plt.xlabel('Product Name')
plt.ylabel('Rating Count')
plt.title('Top 10 Products by Rating Count')
plt.xticks(rotation=90, ha='right') # Rotate labels and align right
plt.subplots_adjust(bottom=0.4) # Manually adjust bottom margin, slightly increased
plt.show()

"""## Final Task

### Subtask:
Summarize the findings, including the top-selling products identified and the limitations regarding monthly revenue calculation due to missing date information. Provide clear and concise conclusions.

## Summary:

### Q&A
*   **What are the top-selling products based on the analysis?**
    The top-selling products, based on `rating_count` as a proxy for popularity, include "Amazon Basics High-Speed HDMI Cable" with over 400,000 ratings and "boAt Bassheads 100 in Ear Wired Earphones" with over 300,000 ratings.
*   **Why is calculating monthly revenue not possible with the current dataset?**
    Calculating monthly revenue is not possible because the dataset lacks any date or timestamp information, which is essential for tracking sales over time.

### Data Analysis Key Findings
*   All specified numerical columns (`discounted_price`, `actual_price`, `discount_percentage`, `rating`, `rating_count`) were successfully cleaned by removing special characters and converted to appropriate numeric data types: `discounted_price` and `actual_price` to `float64`, `discount_percentage` to `int64`, `rating` to `float64` (handling `NaN` for non-numeric entries), and `rating_count` to `Int64` (nullable integer, handling `NaN`).
*   The top-selling products were identified based on `rating_count`. The top 10 products include "Amazon Basics High-Speed HDMI Cable" and "boAt Bassheads 100 in Ear Wired Earphones," which consistently ranked highest with rating counts exceeding 400,000 and 300,000 respectively, indicating significant popularity.
*   The analysis confirmed that monthly revenue cannot be calculated due to the complete absence of any date or timestamp information within the dataset.

### Insights or Next Steps
*   Investigate potential product variations or duplicates among top-selling items to consolidate product views and ensure accurate sales aggregation if `product_name` might represent different SKUs.
*   To enable more comprehensive sales analysis, such as monthly revenue tracking or trend analysis, future data collection should include order dates or timestamps for each transaction.
"""